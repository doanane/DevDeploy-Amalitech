# app/api/webhooks.py
from fastapi import APIRouter, Depends, HTTPException, status, Header, Request, BackgroundTasks
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from typing import Optional, Dict, Any, List
import json
import uuid
from datetime import datetime, timezone

from app.database import get_db
from app.models.project import Project
from app.models.build import Build
from app.models.webhook import WebhookEvent as WebhookEventModel
from app.schemas.webhook import (
    WebhookConfig,
    WebhookTestRequest,
    GitHubWebhookPayload
)
# IMPORTANT: Don't import WebhookEvent from schemas here - it causes circular import
# We'll import it locally in the function that needs it
from app.services.webhook_parser import WebhookVerifier, GitHubWebhookParser
from app.api.auth import get_current_user
from app.models.user import User

router = APIRouter(prefix="/webhooks", tags=["webhooks"])

@router.post("/github", status_code=202)
async def github_webhook(
    request: Request,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    x_hub_signature_256: Optional[str] = Header(None),
    x_github_event: Optional[str] = Header(None),
    x_github_delivery: Optional[str] = Header(None),
):
    """
    GitHub webhook receiver endpoint
    """
    try:
        body_bytes = await request.body()
        body_json = await request.json()
        
        headers_dict = dict(request.headers)
        
        webhook_event = WebhookEventModel(
            event_type=x_github_event or "unknown",
            delivery_id=x_github_delivery or str(uuid.uuid4()),
            signature=x_hub_signature_256,
            status="received",
            payload=body_json,
            headers=headers_dict,
            project_id=None,
        )
        
        db.add(webhook_event)
        db.commit()
        db.refresh(webhook_event)
        
        background_tasks.add_task(
            process_github_webhook,
            webhook_event.id,
            body_bytes,
            x_hub_signature_256,
            x_github_event,
            x_github_delivery,
        )
        
        return {
            "status": "accepted",
            "message": "Webhook received and queued for processing",
            "event_id": webhook_event.id,
            "event_type": x_github_event,
        }
        
    except json.JSONDecodeError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid JSON payload"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing webhook: {str(e)}"
        )

@router.post("/test", response_model=dict)
async def test_webhook(
    test_request: WebhookTestRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Test webhook endpoint - simulates a GitHub webhook
    """
    project = db.query(Project).filter(
        Project.owner_id == current_user.id
    ).first()
    
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No projects found for testing"
        )
    
    test_payload = test_request.payload or {
        "action": "test",
        "repository": {
            "name": project.name,
            "html_url": project.repository_url,
        },
        "sender": {
            "login": "test_user",
        },
        "zen": "Keep it logically awesome.",
    }
    
    webhook_event = WebhookEventModel(
        event_type=test_request.event_type.value,
        delivery_id=str(uuid.uuid4()),
        status="received",
        payload=test_payload,
        headers={"x-test-event": "true"},
        project_id=project.id,
    )
    
    db.add(webhook_event)
    db.commit()
    db.refresh(webhook_event)
    
    process_test_webhook(webhook_event.id, db)
    
    return {
        "status": "success",
        "message": f"Test webhook {test_request.event_type.value} processed",
        "event_id": webhook_event.id,
        "project_id": project.id,
    }

@router.get("/config/{project_id}", response_model=WebhookConfig)
async def get_webhook_config(
    project_id: int,
    request: Request,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get webhook configuration for a project
    """
    project = db.query(Project).filter(
        Project.id == project_id,
        Project.owner_id == current_user.id
    ).first()
    
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )
    
    if not project.webhook_url:
        project.webhook_url = f"{request.base_url}webhooks/github"
        db.commit()
    
    if not project.webhook_secret:
        import secrets
        project.webhook_secret = secrets.token_hex(32)
        db.commit()
    
    return WebhookConfig(
        webhook_url=project.webhook_url,
        secret=project.webhook_secret,
        events=["push", "workflow_run", "check_run"]
    )

@router.get("/events/{project_id}", response_model=List[dict])  # Use dict instead of WebhookEvent
async def get_webhook_events(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    skip: int = 0,
    limit: int = 50,
):
    """
    Get webhook events for a project
    """
    project = db.query(Project).filter(
        Project.id == project_id,
        Project.owner_id == current_user.id
    ).first()
    
    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )
    
    events = db.query(WebhookEventModel).filter(
        WebhookEventModel.project_id == project_id
    ).order_by(
        WebhookEventModel.received_at.desc()
    ).offset(skip).limit(limit).all()
    
    # Convert to dict to avoid Pydantic issues
    return [
        {
            "id": event.id,
            "event_type": event.event_type,
            "action": event.action,
            "delivery_id": event.delivery_id,
            "status": event.status,
            "project_id": event.project_id,
            "received_at": event.received_at,
            "processed_at": event.processed_at,
        }
        for event in events
    ]

# Background task functions
async def process_github_webhook(
    event_id: int,
    raw_body: bytes,
    signature: Optional[str],
    event_type: Optional[str],
    delivery_id: Optional[str],
):
    from app.database import SessionLocal
    db = SessionLocal()
    
    try:
        webhook_event = db.query(WebhookEventModel).filter(
            WebhookEventModel.id == event_id
        ).first()
        
        if not webhook_event:
            return
        
        webhook_event.status = "processing"
        db.commit()
        
        payload = webhook_event.payload
        parsed_data = GitHubWebhookParser.parse_event(
            webhook_event.headers,
            payload
        )
        
        project = find_project_from_webhook(db, payload)
        
        if project:
            webhook_event.project_id = project.id
            
            if project.webhook_secret and signature:
                is_valid = WebhookVerifier.verify_github_signature(
                    raw_body,
                    signature,
                    project.webhook_secret
                )
                
                if not is_valid:
                    webhook_event.status = "failed"
                    db.commit()
                    return
            
            if event_type == "workflow_run":
                process_workflow_run_event(db, project, payload)
            elif event_type == "check_run":
                process_check_run_event(db, project, payload)
            elif event_type == "push":
                process_push_event(db, project, payload)
        
        webhook_event.status = "processed"
        webhook_event.processed_at = datetime.now(timezone.utc)
        db.commit()
        
    except Exception as e:
        print(f"Error processing webhook: {e}")
        if db:
            webhook_event.status = "failed"
            db.commit()
    finally:
        if db:
            db.close()

def process_test_webhook(event_id: int, db: Session):
    webhook_event = db.query(WebhookEventModel).filter(
        WebhookEventModel.id == event_id
    ).first()
    
    if webhook_event:
        webhook_event.status = "processed"
        webhook_event.processed_at = datetime.now(timezone.utc)
        db.commit()

def find_project_from_webhook(db: Session, payload: Dict[str, Any]) -> Optional[Project]:
    repo_url = payload.get("repository", {}).get("html_url")
    if not repo_url:
        return None
    
    project = db.query(Project).filter(
        Project.repository_url.ilike(f"%{repo_url}%")
    ).first()
    
    return project

def process_workflow_run_event(db: Session, project: Project, payload: Dict[str, Any]):
    workflow_run = payload.get("workflow_run", {})
    conclusion = workflow_run.get("conclusion")
    head_sha = workflow_run.get("head_sha")
    
    if conclusion in ["success", "failure", "cancelled"]:
        build = db.query(Build).filter(
            Build.project_id == project.id,
            Build.commit_hash == head_sha
        ).first()
        
        if build:
            build.status = "success" if conclusion == "success" else "failed"
            build.completed_at = datetime.now(timezone.utc)
            db.commit()

def process_check_run_event(db: Session, project: Project, payload: Dict[str, Any]):
    check_run = payload.get("check_run", {})
    conclusion = check_run.get("conclusion")
    head_sha = check_run.get("head_sha")
    
    if conclusion in ["success", "failure"]:
        build = db.query(Build).filter(
            Build.project_id == project.id,
            Build.commit_hash == head_sha
        ).first()
        
        if build:
            build.status = "success" if conclusion == "success" else "failed"
            db.commit()

def process_push_event(db: Session, project: Project, payload: Dict[str, Any]):
    head_commit = payload.get("head_commit", {})
    commit_hash = head_commit.get("id")
    commit_message = head_commit.get("message")
    
    if commit_hash and project.status == "active":
        from app.services.build_runner import trigger_build
        trigger_build(db, project.id, commit_hash, commit_message)